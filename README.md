# compiler
## Формирование AST дерева
### Сборка
Для сборки(отдельно блока для формирования дерева) необходимо выполнить следующие команды:

```
    mkdir build
    cd build
    cmake ..
    make
```
### Описание алгоритма

```
	std::string input_value;
	AST_base* last_node;
```
В глобальную переменную input_value записывается буффер с кодом, на основе которого необходимо построить дерево.
Для возможности считывания даннных из std::string переопределена функция YY_INPUT (см. lexer_ast.l)
last_node - глобальная переменная, хранит в себе указатель на последнее обработанное правило (правила обрабатываются
не в порядке следования во входной строке, а в поредке их определения в .y файле).

```
struct AST_base{
    int nodetype; 
};
struct AST_leaf:public AST_base{ // лист
    char* value;
};

struct AST_node:public AST_base{ // узел
    std::vector<AST_base*> subtrees;
    AST_base* prev = nullptr; //указатель на предыд. узел
    AST_base* next = nullptr; //указатель на след. узел
};
```
В nodetype используются значения enum NodeT:

```
#define NodeT_CONSTANT 4 // первые <NodeT_CONSTANT> членов enum NodeT могут использоваться в AST_leaf,
                         //остальные - в AST_node. Введение константы помогает проще различать листья и узлы.
enum NodeT {
    NT_NUM, // число
    NT_COMPARE, // символ сравнения(<,>,==,<=,>=)
    NT_IDENT, // идентификатор переменной/функции
    NT_DATA_TYPE, // название типа данных
    NT_ADD, //сложение
    NT_SUB, // вычитание
    NT_MUL, // умножение
    NT_DIV, // деление
    NT_ABS, // модуль
    NT_NEG, // отрицательное число
    NT_ASSIGN, // присваивание
    NT_INIT_LIST, // список инициализации
    NT_VARDECL, // объявление переменной (начинается с let)
    NT_IFELSE, // конструкция if-else
    NT_COND, // сравнение (a>=b)
    NT_FNDECL, // объявление функции
    NT_TYPED_VAR, // при объявлении функции x: i32
    NT_IL_conc, // при объявлении функции список входных параметров
    NT_FN_CALL, // вызов функции (не обязательно оканчивается на ; может и вызов в выражении)
    NT_NOT, // логическое отрицание
    NT_LOOP, // цикл
    NT_NULL // пустой узел(без свойств)
};
```

#### общее описание структуры данных

Если не рассматривать указатели prev и next, то дерево является обыкновенным AST деревом с общим корнем.
Пример:
```
    let a=9;
    let b=a;
    let c=m;
```
Если не рассматривать указатели prev и next, то такой код будет преобразован в 3 независимых равноправных узла с типами NT_VARDECL,
каждый из которых в списке поддеревьев содержит указатель на соответствующий узел NT_ASSIGN(присваивание), который, в свою очередь,
в списке поддеревьев содержит указатели на два листа с типами NT_IDENT, соответствующие идентификаторам переменных.
Однако если прорабатывать идею компилятора дальше, нам будет нужно иметь возможность определять, объявлена ли переменная или функция
к моменту использования. По этой причине вводятся указатели на предыдущий и следующий узлы. Теперь AST дерево представляет из себя
двусвязный список один из элементов которого не имеет предка(корень). Элементы списка - узлы AST_node.


##### правило commands в файле .y

commands - возможные команды верхнего уровня.
Все остальные команды - нижнего уровня.
Такой командой может либо одна из команд нижнего (1), либо следующие друг за другом комманда нижнего и верхнего уровней(именно в такой последовательности)(2).
Это позволяет распознавать последовательность комманд.
```
commands:
(1) var_decl
(2) var_decl commands  (рекурсия)
```

В первом случае значение команды commands будет равно значению команды соответствующей команды нижнего уровня. Во втором случае собственное значение - также
значение первой команды(нижнего уровня), но перед этим будут с помощью указателей prev и next будет установлен порядок следования команд в коде (и, соответственно, и двусвязном списке):

```
(1) self = var_decl 
(2):
var_decl->next = commands (здесь формально)
commands->prev = var_decl
self = var_decl
```


##### AST_node.subtrees
Рассмотрим пример:

```
let r=p;(0)
if a==f {
    let s=i; (*)
    let c=a; (*1)
}
else {
    let x=u; (**)
    let v=i; (**1)
}
let a=o;(2)
```
Конструкция  ``` if <условие> { <список команд 1> } else { <список команд 2> } ``` рассматривается как единое целое. Это AST_node с typename = NT_IFELSE.
В процессе работы грамматического анализатора сначала будут определены объявления переменных.
Далее уже будут определены команды команды высшего уровня.
Таким образом, поддеревьями узла IF_ELSE будут:
1) узел с условием(а у него в поддеревьях два листа с типами NT_IDENT и со значениями - именами переменных)
2) узел (*), так как это первое действие в соответствующем блоке кода. По его next можно попасть в (*1), и так далее по этому блоку кода, пока элемент.next != nullptr. 
    nullptr в next будет означать конец блока кода
3) узел (**) - аналогично
Если if не содержит блока else, то в массиве поддеревьев будет только два элемента

Между (0),(2) и if-else будут построены соответсвующие порядковые отношения при помощи их next и prev.

Общее правило следования аргументов в массиве subtrees узла:
***'Сначала идет условие(если есть), далее правила в порядке их следования в строке'***


Про свойства, предыдущий(prev) и следующий(next) узел см. пример и ниже:


```
...
if a==w {
	let f=o;
	i=e;
}
let r=h;
...
```

Здесь:

prev:
if для let f=o;
if для let r=h;

next:
let r=h; для if

свойства:
a==w, {let f=o;i=e;} для if

(!)  if не является prev для a==w, так как правило верхнего уровня commands не включает в себя правило нижнего уровня compare,
и нет необходимости подниматься из compare выше. В данном случае не будем выполнять лишнее действие


Блоки вида:

```
((AST_node*)$7)->prev = $$; 
```

нужны для возможности подняться вверх к корню из любого узла. По это причине данные блоки присутствуют не только commands:<...>(правиле верхнего уровня),
но и в правилах нижнего уровня, вроде

```
if_else: IFTOK condition '{' commands '}'
    {
        auto b = newast(NT_NULL, {});
        $$ = newast(NT_IFELSE, {$2, $4, b});
        ((AST_node*)$4)->prev = $$;
    }
```
Хотя токен commands в данном случае не является коммандой, выполняемой после блока if-else, а является поддеревом этого блока, 
переопределение prev помогает подняться из блока кода, выполняемого при истинности условия if, во внешний блок кода. 
При необходимости отличать поддерево(свойство) узла, от следующего за ним узла, можно посмотреть на указатель next (см (*) ниже).

Пусть el1 - некий узел
el2 - другой узел,и el2.prev = el1 (формально, здесь опускаются операторы взятия адреса, преобразования типов и т.д.)
el2 не следует за el1, а является его свойством (свойством if называется в т.ч. блок кода, выполняемый при истинности условия if)
Пусть el3 - узел, следующий за el1
Тогда:
el2.prev = el1
el3.prev = el1
el1.next = el3 (*)
если бы после el1 не шел el3, то было бы el1.next = nullptr
